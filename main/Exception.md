# 异常
1. 通过将非运行期异常转换为运行期异常（RuntimeException），可以将接口上的显式的异常声明去掉，例如，在service层的代码中调用Session类方法执行sql，将方法抛出的SQLException转为了DbException。
2. 《Java核心技术-11.1 处理异常》中：异常处理的任务就是将控制权从错误产生的地方转移给能够处理这种情况的错误处理器。  
**本人注释：**向用户报告错误也是一种错误处理器。
3. 《Java核心技术-11.2 捕获异常》中：通常，应该捕获那些知道如何处理的异常，而将那些不知道怎样处理的异常传递出去。  
**本人注释：**有时候，有些异常即使抛出去也没有地方有办法去处理它，则还不如就地解决掉它，就像从网上摘录的话：“异常最好能在距发生异常的最近的地方被处理，如果继续抛出到上层，也不能被处理掉，为什么不立即处理掉呢？”，将一个checked异常转为一个runtime异常，也是一种处理方式。例如：在service层的代码中调用Session类方法执行sql，将方法抛出的SQLException转为了DbException。
4. 有时候，不能在最近的地方将非运行期异常处理掉或转换为运行期异常：因为方法的间接调用者（若干层调用）能需要通过捕获该非运行期异常来确定某些事情，所以要一直抛到那里进行处理或转换为运行期异常。正因如此，所以Session的执行sql的方法中没有将SQLException进行转为DbException，而是又直接传出去，由service层的代码来转为DbException。
5. 将意外的情况作为异常来处理，是比较合理的办法，例如因数据库配置错误或数据库网络连接中断或sql书写错误导致的意外情况都应该作为异常抛到最外层的表示层去处理（显示给用户：数据库异常），而不应该在业务逻辑层通过返回boolean类型来显示更新成功和失败，这是不合理的，而且这样也会把异常的详细信息给丢掉。
6. 使用try/catch处理异常，对于try中某类的方法抛出的非运行期异常，是必须要在catch中捕获的，但这些异常并不是该类的方法要抛出的所有异常，因为还有运行期异常，比如空指针异常（NullPointerException）就不会被捕获并处理（话说回来，其实NullPointerException一般可通过object is null来通过程序判断解决），这个要注意。如果要处理所有异常的，则需要在catch的括号中使用比较上层的异常类型，比如Exception，甚至Throwable。
7. Java的错误异常体系中Throwable类为所有错误异常类的基类，它的子类有Error类和Exception类，而Exception类的子类又有RuntimeException类和非RuntimeException类。所以，如果有个try-catch块的catch()中是Exception类，那么若try块中抛出Error或其子类的对象，则catch不会捕获到它，如果要捕获所有的错误异常，则可以在catch()中用Throwable类，这是要注意的。
8. 有本书《Effective Java》挺不错的，它的第8章就是讲异常的，给了我一些启发，最近（2012年1月）我又读了一遍这章。
9. 有篇网上的文章写的也挺好，见“studynote/java/resource/java-exception.html”。
10. 虽然不可能处理所有的异常（checked是必须要显式的，runtime是不必显式的），但考虑到某些场合，尽量多的处理异常，给调用者更多的异常也是不错的做法，如我写的Dbcp.java就对null做了一次抛出异常的操作。
11. service中的方法在处理业务时，有不符合正常逻辑的情况，应通过“抛出异常的方式”来处理，而不是采用“返回一个错误代码字符串”的方式，尽管后者处理起来比较容易。  
在产品级别的逻辑层类方法中，应该定义各种不同的异常，例如在专业的认证方法中，可以抛出用户名不存在异常，密码不正确异常，用户登录状态已无效异常等异常，例如Apache Shiro项目中Subject.login(Token)方法的处理。  
但在项目级别的逻辑类方法中，除了采用上面的方法定义各种不同的异常以外，还可以从简单、方便的角度考虑，直接抛出一个runtime异常，通过异常的字符串来让直接或间接调用者得到异常信息。
12. 关于异常，无论是runtime的还是非runtime的，只要程序抛出此异常，则程序的调用方就会停止程序的执行。
13. servlet中的抛出的异常，如果不做处理，不能够被web.xml中的配置的error-page得到。配置了error-page后，一旦servlet抛出异常发生，容器应该是将request forward到这个error-page，这仅仅是个forward的过程。因此可以将异常放到request的attribute中，然后error-page中就可以从request的attribute中得到这个exception。但这样就需要每个抛出异常的地方都这样做，所以不是个理想的解决方法。
14. 参照Apache Shiro项目，定义一个root exception：ShiroException，该项目的其它exception均继承自exception，这样便于使用该项目的项目根据抛出的exception执行相应操作。
15. 若要定义非RuntimeException，则只要继承Exception即可。有时需要定义非RuntimeException：当需要向调用方报告有这种类型的异常发生，以便调用方可根据抛出的异常类型进行相应的处理，尤其是在产品（相对于项目）代码中。
16. 在service层，对于用户名为空或密码为空的异常，决定：抛出空指针异常，而非每个自己定义一个异常，因为它跟Java中的空指针异常类似，是明显的错误，而不像密码不正确这种不是错误，并且这种空异常在其他情形下也比较普遍，每个都自己定义一个新异常，没必要。这种做运行期异常处理，在Javadoc中提示调用者即可，不强制其处理（非运行期异常）。  